{% extends 'base.html' %}
{% block title %}{{ room.name }} - SecureChat{% endblock %}

{% block extra_css %}
<style>
    .chat-container {
        height: calc(100vh - 250px);
        min-height: 400px;
    }
    
    .messages-area {
        height: calc(100% - 70px);
        overflow-y: auto;
        padding: 1rem;
    }
    
    .message {
        max-width: 70%;
        margin-bottom: 1rem;
        padding: 0.75rem 1rem;
        border-radius: 15px;
        position: relative;
    }
    
    .message.sent {
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        margin-left: auto;
        border-bottom-right-radius: 5px;
    }
    
    .message.received {
        background: rgba(255,255,255,0.1);
        border-bottom-left-radius: 5px;
    }
    
    .message .sender {
        font-size: 0.75rem;
        color: rgba(255,255,255,0.7);
        margin-bottom: 0.25rem;
    }
    
    .message .time {
        font-size: 0.7rem;
        color: rgba(255,255,255,0.5);
        text-align: right;
        margin-top: 0.25rem;
    }
    
    .message-input-area {
        padding: 1rem;
        background: rgba(0,0,0,0.2);
        border-radius: 0 0 15px 15px;
    }
    
    .member-list {
        max-height: 400px;
        overflow-y: auto;
    }
    
    .member-item {
        display: flex;
        align-items: center;
        padding: 0.5rem;
        border-radius: 8px;
        margin-bottom: 0.25rem;
    }
    
    .member-item:hover {
        background: rgba(255,255,255,0.05);
    }
    
    .online-indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 0.5rem;
    }
    
    .online-indicator.online {
        background: var(--success-color);
    }
    
    .online-indicator.offline {
        background: var(--text-muted);
    }
    
    .typing-indicator {
        display: none;
        padding: 0.5rem 1rem;
        color: var(--text-muted);
        font-style: italic;
    }
    
    .encryption-notice {
        text-align: center;
        padding: 0.5rem;
        background: rgba(0, 217, 165, 0.1);
        border-radius: 10px;
        margin-bottom: 1rem;
        font-size: 0.85rem;
        color: var(--success-color);
    }
</style>
{% endblock %}

{% block content %}
<div class="row">
    <!-- Chat Area -->
    <div class="col-lg-9">
        <div class="card chat-container">
            <div class="card-header d-flex justify-content-between align-items-center">
                <div>
                    <h5 class="mb-0">
                        {% if room.room_type == 'private' %}
                        <i class="bi bi-lock-fill me-2"></i>
                        {% else %}
                        <i class="bi bi-globe me-2"></i>
                        {% endif %}
                        {{ room.name }}
                    </h5>
                    <small class="text-muted">{{ room.description }}</small>
                </div>
                <div>
                    <span class="encryption-badge">
                        <i class="bi bi-shield-lock-fill"></i>E2E Encrypted
                    </span>
                </div>
            </div>
            
            <div class="encryption-notice">
                <i class="bi bi-lock-fill me-2"></i>
                Messages are end-to-end encrypted. Only members can read them.
            </div>
            
            <div class="messages-area" id="messagesArea">
                {% for message in messages %}
                <div class="message {% if message.sender == request.user %}sent{% else %}received{% endif %}" 
                     data-message-id="{{ message.id }}"
                     data-encrypted="{{ message.encrypted_content }}">
                    {% if message.sender != request.user %}
                    <div class="sender">{{ message.sender.username }}</div>
                    {% endif %}
                    <div class="content">
                        <span class="decrypted-content">
                            <i class="bi bi-hourglass-split"></i> Decrypting...
                        </span>
                    </div>
                    <div class="time">{{ message.timestamp|time:"H:i" }}</div>
                </div>
                {% empty %}
                <div class="text-center text-muted py-5">
                    <i class="bi bi-chat-dots" style="font-size: 3rem;"></i>
                    <p class="mt-2">No messages yet. Start the conversation!</p>
                </div>
                {% endfor %}
            </div>
            
            <div class="typing-indicator" id="typingIndicator">
                <i class="bi bi-three-dots"></i> <span id="typingUser"></span> is typing...
            </div>
            
            <div class="message-input-area">
                <form id="messageForm" class="d-flex gap-2">
                    <input type="text" id="messageInput" class="form-control" 
                           placeholder="Type your message..." autocomplete="off">
                    <button type="submit" class="btn btn-primary">
                        <i class="bi bi-send-fill"></i>
                    </button>
                </form>
            </div>
        </div>
        
        <div class="mt-3">
            <form method="post" action="{% url 'chat:leave_room' room.id %}" class="d-inline">
                {% csrf_token %}
                <button type="submit" class="btn btn-outline-danger btn-sm">
                    <i class="bi bi-box-arrow-left me-1"></i>Leave Room
                </button>
            </form>
        </div>
    </div>
    
    <!-- Members Sidebar -->
    <div class="col-lg-3">
        <div class="card">
            <div class="card-header">
                <i class="bi bi-people me-2"></i>Members ({{ members|length }})
            </div>
            <div class="card-body member-list">
                {% for member in members %}
                <div class="member-item">
                    <span class="online-indicator {% if member.user.id in online_user_ids %}online{% else %}offline{% endif %}"></span>
                    <span>{{ member.user.username }}</span>
                    {% if member.role == 'admin' %}
                    <small class="ms-auto text-warning"><i class="bi bi-star-fill"></i></small>
                    {% elif member.role == 'moderator' %}
                    <small class="ms-auto text-info"><i class="bi bi-shield-fill"></i></small>
                    {% endif %}
                </div>
                {% endfor %}
            </div>
        </div>
        
        <div class="card mt-3">
            <div class="card-header">
                <i class="bi bi-shield-check me-2"></i>Security
            </div>
            <div class="card-body">
                <p class="small text-muted mb-2">
                    <i class="bi bi-lock-fill me-1"></i>
                    All messages are encrypted with XChaCha20-Poly1305
                </p>
                <p class="small text-muted mb-0">
                    <i class="bi bi-key-fill me-1"></i>
                    Key exchange via X25519 ECDH
                </p>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tweetnacl-util@0.15.1/nacl-util.min.js"></script>
<script>
    // Room configuration
    const roomId = "{{ room.id }}";
    const currentUserId = "{{ request.user.id }}";
    const currentUsername = "{{ request.user.username }}";
    const encryptedRoomKey = "{{ encrypted_room_key }}";
    
    // WebSocket connection
    let socket = null;
    let roomKey = null;
    
    // Initialize encryption
    async function initializeEncryption() {
        try {
            // Decode the room key (in production, this would be properly decrypted)
            roomKey = nacl.util.decodeBase64(encryptedRoomKey);
            console.log("Encryption initialized");
            
            // Decrypt existing messages
            decryptMessages();
        } catch (error) {
            console.error("Failed to initialize encryption:", error);
        }
    }
    
    // Encrypt message
    function encryptMessage(plaintext) {
        const nonce = nacl.randomBytes(24);
        const messageBytes = nacl.util.decodeUTF8(plaintext);
        const encrypted = nacl.secretbox(messageBytes, nonce, roomKey);
        
        return {
            ciphertext: nacl.util.encodeBase64(encrypted),
            nonce: nacl.util.encodeBase64(nonce)
        };
    }
    
    // Decrypt message
    function decryptMessage(encryptedContent) {
        try {
            // Parse the encrypted content (format: nonce:ciphertext)
            const parts = encryptedContent.split(':');
            if (parts.length !== 2) {
                // Try base64 decode for simple format
                const decoded = JSON.parse(atob(encryptedContent));
                const nonce = nacl.util.decodeBase64(decoded.nonce);
                const ciphertext = nacl.util.decodeBase64(decoded.ciphertext);
                const decrypted = nacl.secretbox.open(ciphertext, nonce, roomKey);
                
                if (!decrypted) {
                    return "[Unable to decrypt]";
                }
                
                return nacl.util.encodeUTF8(decrypted);
            }
            
            const nonce = nacl.util.decodeBase64(parts[0]);
            const ciphertext = nacl.util.decodeBase64(parts[1]);
            const decrypted = nacl.secretbox.open(ciphertext, nonce, roomKey);
            
            if (!decrypted) {
                return "[Unable to decrypt]";
            }
            
            return nacl.util.encodeUTF8(decrypted);
        } catch (error) {
            console.error("Decryption error:", error);
            return "[Decryption failed]";
        }
    }
    
    // Decrypt all messages on page
    function decryptMessages() {
        document.querySelectorAll('.message').forEach(msg => {
            const encrypted = msg.dataset.encrypted;
            if (encrypted) {
                const contentEl = msg.querySelector('.decrypted-content');
                try {
                    const decrypted = decryptMessage(encrypted);
                    contentEl.textContent = decrypted;
                } catch (e) {
                    contentEl.textContent = encrypted; // Show encrypted if decryption fails
                }
            }
        });
    }
    
    // Connect WebSocket
    function connectWebSocket() {
        const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const wsUrl = `${wsScheme}://${window.location.host}/ws/chat/${roomId}/`;
        
        socket = new WebSocket(wsUrl);
        
        socket.onopen = function(e) {
            console.log("WebSocket connected");
        };
        
        socket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            handleSocketMessage(data);
        };
        
        socket.onclose = function(e) {
            console.log("WebSocket disconnected, reconnecting...");
            setTimeout(connectWebSocket, 3000);
        };
        
        socket.onerror = function(e) {
            console.error("WebSocket error:", e);
        };
    }
    
    // Handle incoming WebSocket messages
    function handleSocketMessage(data) {
        switch(data.type) {
            case 'message':
                displayMessage(data);
                break;
            case 'typing':
                showTypingIndicator(data);
                break;
            case 'user_join':
                showSystemMessage(`${data.username} joined the room`);
                break;
            case 'user_leave':
                showSystemMessage(`${data.username} left the room`);
                break;
        }
    }
    
    // Display a new message
    function displayMessage(data) {
        const messagesArea = document.getElementById('messagesArea');
        const isSent = data.sender_id === currentUserId;
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
        messageDiv.dataset.messageId = data.message_id;
        
        let content = data.encrypted_content;
        try {
            content = decryptMessage(data.encrypted_content);
        } catch (e) {
            console.error("Failed to decrypt message:", e);
        }
        
        messageDiv.innerHTML = `
            ${!isSent ? `<div class="sender">${data.sender_username}</div>` : ''}
            <div class="content">${escapeHtml(content)}</div>
            <div class="time">${new Date(data.timestamp).toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit'})}</div>
        `;
        
        messagesArea.appendChild(messageDiv);
        messagesArea.scrollTop = messagesArea.scrollHeight;
    }
    
    // Show system message
    function showSystemMessage(text) {
        const messagesArea = document.getElementById('messagesArea');
        const div = document.createElement('div');
        div.className = 'text-center text-muted small my-2';
        div.textContent = text;
        messagesArea.appendChild(div);
        messagesArea.scrollTop = messagesArea.scrollHeight;
    }
    
    // Show typing indicator
    function showTypingIndicator(data) {
        if (data.user_id !== currentUserId) {
            const indicator = document.getElementById('typingIndicator');
            const userSpan = document.getElementById('typingUser');
            
            if (data.is_typing) {
                userSpan.textContent = data.username;
                indicator.style.display = 'block';
            } else {
                indicator.style.display = 'none';
            }
        }
    }
    
    // Send message
    function sendMessage(plaintext) {
        if (!socket || socket.readyState !== WebSocket.OPEN) {
            console.error("WebSocket not connected");
            return;
        }
        
        // Encrypt the message
        const encrypted = encryptMessage(plaintext);
        const encryptedContent = btoa(JSON.stringify(encrypted));
        
        // Compute hash for integrity
        const hash = sha256(plaintext);
        
        socket.send(JSON.stringify({
            type: 'message',
            encrypted_content: encryptedContent,
            content_hash: hash,
            message_type: 'text'
        }));
    }
    
    // Simple SHA-256 hash (for integrity checking)
    async function sha256(message) {
        const msgBuffer = new TextEncoder().encode(message);
        const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }
    
    // Escape HTML
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Handle form submission
    document.getElementById('messageForm').addEventListener('submit', function(e) {
        e.preventDefault();
        const input = document.getElementById('messageInput');
        const message = input.value.trim();
        
        if (message) {
            sendMessage(message);
            input.value = '';
        }
    });
    
    // Handle typing
    let typingTimeout;
    document.getElementById('messageInput').addEventListener('input', function() {
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({
                type: 'typing',
                is_typing: true
            }));
            
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                socket.send(JSON.stringify({
                    type: 'typing',
                    is_typing: false
                }));
            }, 2000);
        }
    });
    
    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
        initializeEncryption();
        connectWebSocket();
        
        // Scroll to bottom
        const messagesArea = document.getElementById('messagesArea');
        messagesArea.scrollTop = messagesArea.scrollHeight;
    });
</script>
{% endblock %}
